import React, { createContext, useContext, useState, useEffect } from 'react';
import { format } from 'date-fns';
import { generateQRCodeForCertificate } from '../utils/qrCodeGenerator';
import { emailService } from '../utils/emailService';

interface Certificate {
  id: string;
  studentName: string;
  studentEmail: string;
  institutionName: string;
  institutionId: string;
  courseName: string;
  grade: string;
  issueDate: string;
  completionDate: string;
  blockchainHash: string;
  ipfsHash: string;
  qrCode: string;
  isVerified: boolean;
  verificationStatus: 'pending' | 'verified' | 'rejected';
  fileUrl?: string;
  certificateType: 'degree' | 'diploma' | 'certificate' | 'transcript';
  // Blockchain specific fields
  certId?: `0x${string}`; // Unique identifier on blockchain
  txHash?: `0x${string}`; // Transaction hash from certificate issuance
  issuerAddress?: `0x${string}`; // Ethereum address of issuer
  contentHash?: `0x${string}`; // Hash of certificate content on blockchain
  metadataUri?: string; // URI pointing to certificate metadata
}

interface CertificateContextType {
  certificates: Certificate[];
  addCertificate: (certificateData: Omit<Certificate, 'id' | 'ipfsHash' | 'qrCode' | 'isVerified' | 'blockchainHash' | 'certId' | 'txHash' | 'issuerAddress' | 'contentHash' | 'metadataUri'>) => Promise<string>;
  verifyCertificate: (certificateId: string) => Certificate | null;
  getCertificatesByStudent: (studentEmail: string) => Certificate[];
  getCertificatesByInstitution: (institutionId: string) => Certificate[];
  updateCertificateStatus: (certificateId: string, status: 'verified' | 'rejected') => void;
  generateHash: (data: string) => string;
}

const CertificateContext = createContext<CertificateContextType | undefined>(undefined);

export const useCertificates = () => {
  const context = useContext(CertificateContext);
  if (!context) {
    throw new Error('useCertificates must be used within a CertificateProvider');
  }
  return context;
};

export const CertificateProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [certificates, setCertificates] = useState<Certificate[]>([]);

  useEffect(() => {
    // Load certificates from localStorage
    const storedCertificates = localStorage.getItem('certificates');
    if (storedCertificates) {
      setCertificates(JSON.parse(storedCertificates));
    } else {
      // Initialize with demo certificates
      const demoCertificate: Certificate = {
        id: 'cert-001',
        studentName: 'Alice Johnson',
        studentEmail: 'student@demo.com',
        institutionName: 'Stanford University',
        institutionId: '2',
        courseName: 'Computer Science - Bachelor of Science',
        grade: 'A',
        issueDate: format(new Date(), 'yyyy-MM-dd'),
        completionDate: format(new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), 'yyyy-MM-dd'),
        blockchainHash: '0x1234567890abcdef...',
        ipfsHash: 'QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o',
        qrCode: 'data:image/png;base64,...',
        isVerified: true,
        verificationStatus: 'verified',
        certificateType: 'degree'
      };
      
      const demoCertificates = [demoCertificate];
      setCertificates(demoCertificates);
      localStorage.setItem('certificates', JSON.stringify(demoCertificates));
    }
  }, []);

  const generateHash = (data: string): string => {
    // Simulate SHA-256 hash generation
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return `0x${Math.abs(hash).toString(16)}`;
  };

  const addCertificate = async (certificateData: Omit<Certificate, 'id' | 'ipfsHash' | 'qrCode' | 'isVerified' | 'blockchainHash' | 'certId' | 'txHash' | 'issuerAddress' | 'contentHash' | 'metadataUri'>): Promise<string> => {
    const id = `cert-${Date.now()}`;
    const ipfsHash = `Qm${Math.random().toString(36).substr(2, 42)}`;
    
    // Generate QR code as data URL
    const qrCode = await generateQRCodeForCertificate(id);

    // Generate blockchain hash from certificate data
    const dataForHash = {
      id,
      studentName: certificateData.studentName,
      studentEmail: certificateData.studentEmail,
      institutionName: certificateData.institutionName,
      courseName: certificateData.courseName,
      grade: certificateData.grade,
      timestamp: Date.now()
    };
    const blockchainHash = generateHash(JSON.stringify(dataForHash));

    const newCertificate: Certificate = {
      ...certificateData,
      id,
      blockchainHash,
      ipfsHash,
      qrCode,
      isVerified: false,
      verificationStatus: 'pending',
      certId: undefined,
      txHash: undefined,
      issuerAddress: undefined,
      contentHash: undefined,
      metadataUri: undefined
    };

    const updatedCertificates = [...certificates, newCertificate];
    setCertificates(updatedCertificates);
    localStorage.setItem('certificates', JSON.stringify(updatedCertificates));
    
    // Send certificate email to student
    try {
      await emailService.sendCertificateEmail(newCertificate, certificateData.studentEmail);
      console.log('Certificate email sent successfully to:', certificateData.studentEmail);
    } catch (error) {
      console.error('Failed to send certificate email:', error);
    }
    
    // Send verification request emails to all verifiers
    try {
      const verifiers = await emailService.getVerifiers();
      for (const verifier of verifiers) {
        await emailService.sendVerificationRequestEmail(newCertificate, verifier.email, verifier.name);
        console.log('Verification request email sent to:', verifier.email);
      }
    } catch (error) {
      console.error('Failed to send verification request emails:', error);
    }
    
    return id;
  };

  const verifyCertificate = (certificateId: string): Certificate | null => {
    return certificates.find(cert => cert.id === certificateId) || null;
  };

  const getCertificatesByStudent = (studentEmail: string): Certificate[] => {
    return certificates.filter(cert => cert.studentEmail === studentEmail);
  };

  const getCertificatesByInstitution = (institutionId: string): Certificate[] => {
    return certificates.filter(cert => cert.institutionId === institutionId);
  };

  const updateCertificateStatus = (certificateId: string, status: 'verified' | 'rejected'): void => {
    const updatedCertificates = certificates.map(cert => 
      cert.id === certificateId 
        ? { ...cert, verificationStatus: status, isVerified: status === 'verified' }
        : cert
    );
    setCertificates(updatedCertificates);
    localStorage.setItem('certificates', JSON.stringify(updatedCertificates));
  };

  return (
    <CertificateContext.Provider value={{
      certificates,
      addCertificate,
      verifyCertificate,
      getCertificatesByStudent,
      getCertificatesByInstitution,
      updateCertificateStatus,
      generateHash
    }}>
      {children}
    </CertificateContext.Provider>
  );
};

export default CertificateProvider;
